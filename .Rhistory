else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
print("d")
stop()
print("e")
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data)) #pour son fonctionnement mathématique voir paragraphe 3.7.2, Husson et al. 2010
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])}
assign("description_groupes", description_groupes, envir = .GlobalEnv)
View(description_groupes[1])
windows(title = 'principaux composants par groupe')
plot(description_groupes)
data2=split(data_triee[,1:ncol(data_triee)-1],data_triee[,ncol(data_triee)])
assign("data_split", data2, envir = .GlobalEnv)
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
grappe(data)
#' L'analyse de grappe ou classification hiérarchique ascendante est une technique de classification classique en analyse de données. Pour une revue synthétique, voir Gordon 1987
#' @param data fichier data
#' @param normalize booleen. Vrai si on ramène à 100, faux sinon. Vrai par défaut
#' @param methode string. methode d'analyse simple ou log-lineaire
#' @param h hauteur decoupage groupe
#' @param k nombre decoupage groupe
#' @return hc un dendogramme
#' @export
#' @importFrom stats hclust rect.hclust cutree dist
#' @importFrom utils View
#' @importFrom grDevices windows
#' @importFrom nexus as_composition replace_zero transform_clr
#' @importFrom graphics boxplot
#' @importFrom FactoMineR catdes plotcades
#'
#' @examples
#'
#'
grappe <- function(data,normalize=TRUE,methode='simple',h=NULL,k=NULL){
data_selectionne<-selection_menu(data)
View(data)
print(data)
if (normalize){
nbr_init=ncol(data)
nbr_selectionne=ncol(data_selectionne)
data<-data_selectionne #creation du dataframe a normaliser
for (i in 1:nrow(data)){
data[i,]=data_selectionne[i,]/sum(data_selectionne[i,])*100
}
print(data)
View(data)
}
if (methode=='simple'){
data_norm=scale(data)
print(data)
View(data)
}
else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
stop()
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data)) #pour son fonctionnement mathématique voir paragraphe 3.7.2, Husson et al. 2010
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])}
assign("description_groupes", description_groupes, envir = .GlobalEnv)
View(description_groupes[1])
windows(title = 'principaux composants par groupe')
plot(description_groupes)
data2=split(data_triee[,1:ncol(data_triee)-1],data_triee[,ncol(data_triee)])
assign("data_split", data2, envir = .GlobalEnv)
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
grappe(data)
#' L'analyse de grappe ou classification hiérarchique ascendante est une technique de classification classique en analyse de données. Pour une revue synthétique, voir Gordon 1987
#' @param data fichier data
#' @param normalize booleen. Vrai si on ramène à 100, faux sinon. Vrai par défaut
#' @param methode string. methode d'analyse simple ou log-lineaire
#' @param h hauteur decoupage groupe
#' @param k nombre decoupage groupe
#' @return hc un dendogramme
#' @export
#' @importFrom stats hclust rect.hclust cutree dist
#' @importFrom utils View
#' @importFrom grDevices windows
#' @importFrom nexus as_composition replace_zero transform_clr
#' @importFrom graphics boxplot
#' @importFrom FactoMineR catdes plotcades
#'
#' @examples
#'
#'
grappe <- function(data,normalize=TRUE,methode='simple',h=NULL,k=NULL){
data_selectionne<-selection_menu(data)
View(data)
print(data)
if (normalize){
nbr_init=ncol(data)
nbr_selectionne=ncol(data_selectionne)
data<-data_selectionne #creation du dataframe a normaliser
for (i in 1:nrow(data)){
data[i,]=data_selectionne[i,]/sum(data_selectionne[i,])*100
}
print(data)
View(data)
}
if (methode=='simple'){
data_norm=scale(data)
print(data_norm)
View(data)
}
else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
stop()
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data)) #pour son fonctionnement mathématique voir paragraphe 3.7.2, Husson et al. 2010
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])}
assign("description_groupes", description_groupes, envir = .GlobalEnv)
View(description_groupes[1])
windows(title = 'principaux composants par groupe')
plot(description_groupes)
data2=split(data_triee[,1:ncol(data_triee)-1],data_triee[,ncol(data_triee)])
assign("data_split", data2, envir = .GlobalEnv)
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
grappe(data)
#' L'analyse de grappe ou classification hiérarchique ascendante est une technique de classification classique en analyse de données. Pour une revue synthétique, voir Gordon 1987
#' @param data fichier data
#' @param normalize booleen. Vrai si on ramène à 100, faux sinon. Vrai par défaut
#' @param methode string. methode d'analyse simple ou log-lineaire
#' @param h hauteur decoupage groupe
#' @param k nombre decoupage groupe
#' @return hc un dendogramme
#' @export
#' @importFrom stats hclust rect.hclust cutree dist
#' @importFrom utils View
#' @importFrom grDevices windows
#' @importFrom nexus as_composition replace_zero transform_clr
#' @importFrom graphics boxplot
#' @importFrom FactoMineR catdes plotcades
#'
#' @examples
#'
#'
grappe <- function(data,normalize=TRUE,methode='simple',h=NULL,k=NULL){
data_selectionne<-selection_menu(data)
View(data)
print(data)
if (normalize){
nbr_init=ncol(data)
nbr_selectionne=ncol(data_selectionne)
data<-data_selectionne #creation du dataframe a normaliser
for (i in 1:nrow(data)){
data[i,]=data_selectionne[i,]/sum(data_selectionne[i,])*100
}
print(data)
View(data)
}
if (methode=='simple'){
data_norm=scale(data)
print(data_norm)
print(scale(data_selectionne))
View(data)
}
else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
stop()
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data)) #pour son fonctionnement mathématique voir paragraphe 3.7.2, Husson et al. 2010
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])}
assign("description_groupes", description_groupes, envir = .GlobalEnv)
View(description_groupes[1])
windows(title = 'principaux composants par groupe')
plot(description_groupes)
data2=split(data_triee[,1:ncol(data_triee)-1],data_triee[,ncol(data_triee)])
assign("data_split", data2, envir = .GlobalEnv)
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
grappe(data)
# 5.b. Créer une vignette (fortement recommandé)
usethis::use_vignette(nom)
# 5.b. Créer une vignette (fortement recommandé)
usethis::use_vignette(menu)
library(usethis)
use_vignette(menu)
use_vignette('menu')
build_vignettes()
library(devtools)
build_vignettes()
use_vignette('travail_sur_groupe')
vignette()
use_vignette('Guide')
vignette('dplyr')
vignette('base')
vignette('gert')
vignette('guide')
vignette('Guide')
use_vignette('guide')
use_vignette('nexuq')
vignette('nexus')
vignette('checkmate')
vignette('FAQ')
use_vignette('procedure')
vignette('procedure')
vignette('ArArpackage')
use_vignette('ArArpackage')
use_vignette('Introduction_analyse_XRF')
load("D:/Users/Mag/Desktop/stage ArAr/ArAr/data/tholeithe.rda")
load("D:/Users/Mag/Desktop/stage ArAr/ArAr/data/tholeithe.rda")
utils::R CMD Rd2pdf nom_du_package
utils::R CMD Rd2pdf nom_du_package
utils::R CMD Rd2pdf ArAr
library(utils)
R CMD Rd2pdf ArAr
R CMD Rd2pdf ArAr::
?ArAr
library(ArAr)
?ArAr
?arules
library(abind)
?abind
detach("package:abind", unload = TRUE)
use_data(tholeithe)
library(usethis)
use_data(tholeithe)
import(FactoMineR)
library(FactoMineR)
help(HCPC)
data('tholeithe')
library('ArAr')
grappe(tholeithe)
data('tholeithe')
hc=data('tholeithe')
hc
data("tholeithe")
iris
data()
rock
grappe(rock)
tholeithe
rivers
volcano
geomorphology
data("geomorphology")
geomorphology
View(geomorphology)
data("tholeithe")
library(ArAr)
help(grappe)
library(ArAr)
library(ArAr)
help(grappe)
library(ArAr)
help(grappe)
library(ArAr)
help(grappe)
grappe(rock)
rock<-exclure(rock,'46')
rock<-exclure(rock,'38')
rock<-exclure(rock,'42')
grappe(rock)
grappe(rock,k=2)
grappe(rock,k=25)
22+41+14+5+18
library(ArAr)
setwd("D:/Users/Mag/Desktop/stage ArAr/ArAr/data")
data=read.csv("montpelier.csv",header=T,sep=",",dec=".",row.name=1)
library(ArAr)
setwd("D:/Users/Mag/Desktop/stage ArAr/ArAr/data")
data=read.csv("montpellier.csv",header=T,sep=",",dec=".",row.name=1)
data
library(ArAr)
setwd("D:/Users/Mag/Desktop/stage ArAr/ArAr/data")
data=read.csv("montpellier.csv",header=T,sep=";",dec=".",row.name=1)
data
View(data)
nrow(data)
grappe(data)
grappe(data,k=5)
data_triee
View(data_triee)
grappe(data,k=6)
View(data_triee)
grappe(data,k=6)
grappe(data,k=6)
help(grappe)
help(PCA)
help("plot")
help(hclust)
library(ArAr)
library(ArAr)
library(ArAr)
library(ArAr)
help(grappe)
grappe(ana_dis)
help(ana_dis)
ana_dis(iris[1,3,])
ana_dis(iris[1:3,])
ana_dis(iris[,1:3])
ana_dis(rock)
library(ArAr)
rock
histogramme(iris)
iris
histogramme(iris)
histogramme(iris,'Sepal.Length')
histogramme(iris,'Sepal.Length',1)
dv.new()
dev.new()
dev.new(plot(1,4))
help(catdes)
help(dev.new)
getwd()
setwd()
setwd("D:/Users/Mag/Desktop/stage ArAr/ArAr")
data=read.csv("monpellier.csv")
data=read.csv("monpelier.csv")
data=read.csv("montpellier.csv")
getwd()
setwd("D:/Users/Mag/Desktop/stage ArAr/ArAr/data")
data=read.csv("montpellier.csv")
data
View(data)
data=read.csv("montpellier.csv",sep=";",head=T,dec=".")
save(data)
save(data,"D:/Users/Mag/Desktop/stage ArAr/ArAr/montpellier.rda")
save(data,file="montpellier.rda")
load("D:/Users/Mag/Desktop/stage ArAr/ArAr/data/montpellier.rda")
library(usethis)
use_data(montpellier)
use_data(montpellier,overwrite = T)
load("D:/Users/Mag/Desktop/stage ArAr/ArAr/data/montpellier.rda")
montpellier
View(data)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
help(data)
data('rock')
devtools::check()
library(ArAr)
library(ArAr)
library(ArAr)
library(ArAr)
setwd("D:/Users/Mag/Desktop/stage ArAr/Fichier R")
data=read.csv("ceramiques.csv",header=T,sep=";",dec=".",row.name=1)
grappe(data,k=6)
library(ArAr)
setwd("D:/Users/Mag/Desktop/stage ArAr/ArAr_travail/data")
data=read.csv("Albinia_gt.csv",header=T,sep=";",dec=".",row.name=1)
grappe(data,k=6)
library(ArAr)
library(ArAr)
setwd("D:/Users/Mag/Desktop/stage ArAr/Fichier R")
data=read.csv("ceramiques.csv",header=T,sep=";",dec=".",row.name=1)
grappe(data)
grappe(data,k=6)
q()
library(ArAr)
help(binaire)
00check.log
devtools::00check.log
devtools::check(quiet = FALSE)
usethis::use_data_doc(montpellier)
use_data_doc(montpellier)
load("D:/Users/Mag/Desktop/stage ArAr/ArAr/data/montpellier.rda")
✖✔
"✖✔"
Un dataset contenant pour chaque pays et année les émmissions annuelles de CO2
tholeithe
usethis::use_data_raw()
devtools::load_all()
albinia
montpellier
devtools::load_all()
albinia
usethis::use_data(montpellier,overwrite=TRUE)
usethis::use_data(albinia,overwrite=TRUE)
## code to prepare `DATASET` dataset goes here
montpellier=read.csv("montpellier.csv",header=T,sep=";",dec=".",row.name=1)
montpellier=read.csv("montpellier.csv",header=T,sep=";",dec=".",row.name=1)
getwd()
## code to prepare `DATASET` dataset goes here
setwd("D:/Users/Mag/Desktop/stage ArAr/ArAr/data-raw")
montpellier=read.csv("montpellier.csv",header=T,sep=";",dec=".",row.name=1)
usethis::use_data(montpellier, overwrite = TRUE)
albinia=read.csv("albinia.csv",header=T,sep=";",dec=".",row.name=1)
usethis::use_data(albinia, overwrite = TRUE)
setwd("D:/Users/Mag/Desktop/stage ArAr/ArAr/data-raw")
montpellier=read.csv("montpellier.csv",header=T,sep=",",dec=".",row.name=1)
montpellier
montpellier=read.csv("montpellier.csv",header=T,sep=";",dec=".",row.name=1)
montpellier
albinia=read.csv("albinia.csv",header=T,sep=";",dec=".",row.name=1)
albinia
devtools::check()
devtools::check()
library(ArAr)
devtools::submit_cran()
usethis::use_cran_comments()
install.packages("httr")
devtools::submit_cran()
install.packages("ArAr")
install.packages("ArAr")
