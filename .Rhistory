coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data))
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])
assign("description_groupe", data_triee, envir = .GlobalEnv)
}
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
library(ArAr)
setwd("D:/Users/Mag/Desktop/stage ArAr/ArAr_travail/data")
data=read.csv("Albinia_gt.csv",header=T,sep=";",dec=".",row.name=1)
grappe(data,k=3)
description_groupe
#' L'analyse de grappe ou classification hiérarchique ascendante est une technique de classification classique en analyse de données. Pour une revue synthétique, voir Gordon 1987
#' @param data fichier data
#' @param normalize booleen. Vrai si on ramène à 100, faux sinon. Vrai par défaut
#' @param methode string. methode d'analyse simple ou log-lineaire
#' @param h hauteur decoupage groupe
#' @param k nombre decoupage groupe
#' @return hc un dendogramme
#' @export
#' @importFrom stats dist
#' @importFrom stats hclust rect.hclust cutree
#' @importFrom utils View
#' @importFrom grDevices windows
#' @importFrom nexus as_composition replace_zero transform_clr
#' @importFrom graphics boxplot
#' @importFrom FactoMineR catdes
#'
#' @examples
#'
#'
grappe <- function(data,normalize=TRUE,methode='simple',h=NULL,k=NULL){
data=selection_menu(data)
if (methode=='simple'){
data_norm=scale(data)
}
else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data))
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])
assign("description_groupe", description_groupe, envir = .GlobalEnv)
}
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
grappe(data,k=3)
description_groupe
#' L'analyse de grappe ou classification hiérarchique ascendante est une technique de classification classique en analyse de données. Pour une revue synthétique, voir Gordon 1987
#' @param data fichier data
#' @param normalize booleen. Vrai si on ramène à 100, faux sinon. Vrai par défaut
#' @param methode string. methode d'analyse simple ou log-lineaire
#' @param h hauteur decoupage groupe
#' @param k nombre decoupage groupe
#' @return hc un dendogramme
#' @export
#' @importFrom stats dist
#' @importFrom stats hclust rect.hclust cutree
#' @importFrom utils View
#' @importFrom grDevices windows
#' @importFrom nexus as_composition replace_zero transform_clr
#' @importFrom graphics boxplot
#' @importFrom FactoMineR catdes
#'
#' @examples
#'
#'
grappe <- function(data,normalize=TRUE,methode='simple',h=NULL,k=NULL){
data=selection_menu(data)
if (methode=='simple'){
data_norm=scale(data)
}
else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data))
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])
assign("description_groupe", description_groupes, envir = .GlobalEnv)
}
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
assign("description_groupes", description_groupes, envir = .GlobalEnv)
#' L'analyse de grappe ou classification hiérarchique ascendante est une technique de classification classique en analyse de données. Pour une revue synthétique, voir Gordon 1987
#' @param data fichier data
#' @param normalize booleen. Vrai si on ramène à 100, faux sinon. Vrai par défaut
#' @param methode string. methode d'analyse simple ou log-lineaire
#' @param h hauteur decoupage groupe
#' @param k nombre decoupage groupe
#' @return hc un dendogramme
#' @export
#' @importFrom stats dist
#' @importFrom stats hclust rect.hclust cutree
#' @importFrom utils View
#' @importFrom grDevices windows
#' @importFrom nexus as_composition replace_zero transform_clr
#' @importFrom graphics boxplot
#' @importFrom FactoMineR catdes
#'
#' @examples
#'
#'
grappe <- function(data,normalize=TRUE,methode='simple',h=NULL,k=NULL){
data=selection_menu(data)
if (methode=='simple'){
data_norm=scale(data)
}
else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data))
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])
assign("description_groupes", description_groupes, envir = .GlobalEnv)
}
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
grappe(data,k=3)
description_groupes
description_groupes$test.chi
description_groupes[1]
description_groupes[2]
description_groupes[3]
description_groupes[4]
description_groupes[5]
description_groupes
help(catdes)
#' L'analyse de grappe ou classification hiérarchique ascendante est une technique de classification classique en analyse de données. Pour une revue synthétique, voir Gordon 1987
#' @param data fichier data
#' @param normalize booleen. Vrai si on ramène à 100, faux sinon. Vrai par défaut
#' @param methode string. methode d'analyse simple ou log-lineaire
#' @param h hauteur decoupage groupe
#' @param k nombre decoupage groupe
#' @return hc un dendogramme
#' @export
#' @importFrom stats dist
#' @importFrom stats hclust rect.hclust cutree
#' @importFrom utils View
#' @importFrom grDevices windows
#' @importFrom nexus as_composition replace_zero transform_clr
#' @importFrom graphics boxplot
#' @importFrom FactoMineR catdes
#'
#' @examples
#'
#'
grappe <- function(data,normalize=TRUE,methode='simple',h=NULL,k=NULL){
data=selection_menu(data)
if (methode=='simple'){
data_norm=scale(data)
}
else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data))
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])}
assign("description_groupes", description_groupes, envir = .GlobalEnv)
View(description_groupes[1])
print.catdes(description_groupes)
}
}
data_triee <- data[hc$order, ]
#' L'analyse de grappe ou classification hiérarchique ascendante est une technique de classification classique en analyse de données. Pour une revue synthétique, voir Gordon 1987
#' @param data fichier data
#' @param normalize booleen. Vrai si on ramène à 100, faux sinon. Vrai par défaut
#' @param methode string. methode d'analyse simple ou log-lineaire
#' @param h hauteur decoupage groupe
#' @param k nombre decoupage groupe
#' @return hc un dendogramme
#' @export
#' @importFrom stats dist
#' @importFrom stats hclust rect.hclust cutree
#' @importFrom utils View
#' @importFrom grDevices windows
#' @importFrom nexus as_composition replace_zero transform_clr
#' @importFrom graphics boxplot
#' @importFrom FactoMineR catdes
#'
#' @examples
#'
#'
grappe <- function(data,normalize=TRUE,methode='simple',h=NULL,k=NULL){
data=selection_menu(data)
if (methode=='simple'){
data_norm=scale(data)
}
else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data))
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])}
assign("description_groupes", description_groupes, envir = .GlobalEnv)
View(description_groupes[1])
print.catdes(description_groupes)
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
grappe(data,k=3)
cond(data)
condes(data)
library(ArAr)
library(FactoMineR)
?plotcades
?plot.cades
#' L'analyse de grappe ou classification hiérarchique ascendante est une technique de classification classique en analyse de données. Pour une revue synthétique, voir Gordon 1987
#' @param data fichier data
#' @param normalize booleen. Vrai si on ramène à 100, faux sinon. Vrai par défaut
#' @param methode string. methode d'analyse simple ou log-lineaire
#' @param h hauteur decoupage groupe
#' @param k nombre decoupage groupe
#' @return hc un dendogramme
#' @export
#' @importFrom stats dist
#' @importFrom stats hclust rect.hclust cutree
#' @importFrom utils View
#' @importFrom grDevices windows
#' @importFrom nexus as_composition replace_zero transform_clr
#' @importFrom graphics boxplot
#' @importFrom FactoMineR catdes plotcades
#'
#' @examples
#'
#'
grappe <- function(data,normalize=TRUE,methode='simple',h=NULL,k=NULL){
data=selection_menu(data)
if (methode=='simple'){
data_norm=scale(data)
}
else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data)) #pour son fonctionnement mathématique voir paragraphe 3.7.2, Husson et al. 2010
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])}
assign("description_groupes", description_groupes, envir = .GlobalEnv)
View(description_groupes[1])
plot(description_groupes)
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
library(ArAr)
setwd("D:/Users/Mag/Desktop/stage ArAr/ArAr_travail/data")
data=read.csv("Albinia_gt.csv",header=T,sep=";",dec=".",row.name=1)
#' L'analyse de grappe ou classification hiérarchique ascendante est une technique de classification classique en analyse de données. Pour une revue synthétique, voir Gordon 1987
#' @param data fichier data
#' @param normalize booleen. Vrai si on ramène à 100, faux sinon. Vrai par défaut
#' @param methode string. methode d'analyse simple ou log-lineaire
#' @param h hauteur decoupage groupe
#' @param k nombre decoupage groupe
#' @return hc un dendogramme
#' @export
#' @importFrom stats dist
#' @importFrom stats hclust rect.hclust cutree
#' @importFrom utils View
#' @importFrom grDevices windows
#' @importFrom nexus as_composition replace_zero transform_clr
#' @importFrom graphics boxplot
#' @importFrom FactoMineR catdes plotcades
#'
#' @examples
#'
#'
grappe <- function(data,normalize=TRUE,methode='simple',h=NULL,k=NULL){
data=selection_menu(data)
if (methode=='simple'){
data_norm=scale(data)
}
else if (methode=='logarithme'){
coda=as_composition(data)
coda=replace_zero(coda,10e-7) #le log-ratio n'est pas défini en 0
data_t=transform_clr(coda)
data_norm=scale(data_t)
}
matrice_dist <- dist(data_norm) #matrice des distances euclidiennes
hc <- hclust(matrice_dist,method="average")
#NB : method="average" si classification en affinite moyenne non ponderee
#     method="median" si classification en affinite moyenne ponderee
windows()
if (methode=='simple'){sub='hclust(*,"average") - transformation simple'}
else if (methode=='logarithme'){sub='hclust(*,"average") - transformation log-ratio'}
plot(hc, labels = data$Nom, main = "Dendrogramme",hang=-1,sub=sub, xlab = "Echantillons", ylab = "Distance")
if (!is.null(h)){
rect.hclust(hc,h=h,border=2)
groupes=cutree(hc,h=h)
data$Groupe<-groupes
}
if (!is.null(k)){
rect.hclust(hc,k=k,border=2)
groupes=cutree(hc,k=k)
data$Groupe<-as.factor(groupes)
#windows()
#boxplot(data_triee$CaO~data_triee$Groupe,xlab="groupe",ylab="CaO")
description_groupes <- catdes(data, num.var = ncol(data)) #pour son fonctionnement mathématique voir paragraphe 3.7.2, Husson et al. 2010
for (i in 1:k){
print(description_groupes$quanti[i])
View(description_groupes$quanti[i])}
assign("description_groupes", description_groupes, envir = .GlobalEnv)
View(description_groupes[1])
plot(description_groupes)
}
data_triee <- data[hc$order, ]
assign("data_triee", data_triee, envir = .GlobalEnv)
print("le fichier data a ete modifie et enregistre sous la forme data_triee")
return(hc)
}
grappe(data,k=3)
library(ArAr)
library(ArAr)
?t.test
library(ArAr)
library(ArAr)
usegithub()
library(usethis)
usegithub()
use_github()
use_github()
gitcreds::gitcreds_set()
use_github()
knitr
usethis::use_readme_rmd()
git pull origin main --rebase
library(ArAr)
get push commit origin
git push origin main
data<-selection_menu(data)
